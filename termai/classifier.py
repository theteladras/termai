"""Instruction complexity classifier.

Determines whether an instruction should be handled locally or
delegated to a remote AI provider based on heuristics.
"""

from __future__ import annotations

import re

_MULTI_STEP_MARKERS = re.compile(
    r"\b(and then|after that|followed by|next|finally|first .* then|step \d)"
    r"\b", re.IGNORECASE
)

_COMPLEX_DOMAIN_KEYWORDS = {
    "kubernetes", "k8s", "kubectl", "helm",
    "terraform", "ansible", "vagrant",
    "docker-compose", "docker compose", "dockerfile",
    "nginx", "apache", "systemctl", "systemd",
    "cron", "crontab", "iptables", "firewall",
    "sql", "mysql", "postgres", "psql", "redis",
    "aws", "gcloud", "azure", "s3",
    "ci/cd", "pipeline", "deploy", "rollback",
    "ssl", "tls", "certificate",
    "regex", "regular expression",
    "script", "bash script", "shell script",
}

_SIMPLE_PATTERNS = {
    "list", "show", "print", "display", "check",
    "what is", "who am i", "where am i",
    "version", "status", "help",
}


def classify(instruction: str, local_result: str | None, *, from_fallback: bool = False) -> str:
    """Classify an instruction as "local" or "remote".

    Args:
        instruction: The user's natural language instruction.
        local_result: The command generated by the local model (or None).
        from_fallback: True if local_result came from the keyword fallback.

    Returns:
        "local" if the local result should be used, "remote" if
        the instruction should be delegated to a remote provider.
    """
    lower = instruction.lower().strip()

    if local_result is None and from_fallback:
        return "remote"

    if from_fallback and not local_result:
        return "remote"

    if _is_simple(lower):
        return "local"

    score = _complexity_score(lower, local_result, from_fallback)
    return "remote" if score >= 3 else "local"


def _is_simple(instruction: str) -> bool:
    """Quick check for obviously simple instructions."""
    words = instruction.split()
    if len(words) <= 3:
        return True
    for pattern in _SIMPLE_PATTERNS:
        if instruction.startswith(pattern):
            return True
    return False


def _complexity_score(instruction: str, local_result: str | None, from_fallback: bool) -> int:
    """Compute a complexity score. Higher = more likely to need remote AI."""
    score = 0

    if len(instruction) > 100:
        score += 1
    if len(instruction) > 200:
        score += 1

    if _MULTI_STEP_MARKERS.search(instruction):
        score += 2

    words = instruction.lower().split()
    verb_count = sum(1 for w in words if w in {
        "create", "write", "build", "setup", "configure",
        "install", "deploy", "migrate", "convert", "generate",
        "parse", "transform", "extract", "monitor", "automate",
    })
    if verb_count >= 2:
        score += 1

    for keyword in _COMPLEX_DOMAIN_KEYWORDS:
        if keyword in instruction.lower():
            score += 2
            break

    if any(marker in instruction.lower() for marker in ("pipe", "|", "loop", "for each", "iterate")):
        score += 1

    if from_fallback:
        score += 2

    return score
